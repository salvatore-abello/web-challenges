from collections import defaultdict, Counter, deque
from typing import Iterable, List, Dict, Tuple

def reconstruct_from_ngrams(ngrams: Iterable[str], n: int) -> str:
    """
    Reconstruct a string from a multiset of length-n ngrams.
    Returns one valid reconstruction if it exists, else raises ValueError.

    Assumptions:
    - `ngrams` is a multiset (duplicates allowed).
    - Every ngram has length == n.
    - A reconstruction exists iff the De Bruijn graph has an Eulerian path/cycle
      and the graph (ignoring isolated nodes) is (weakly) connected.
    """
    ngrams = list(ngrams)
    if n <= 0:
        raise ValueError("n must be >= 1")
    if any(len(g) != n for g in ngrams):
        bad = [g for g in ngrams if len(g) != n][:3]
        raise ValueError(f"All n-grams must have length n. Examples of mismatched: {bad}")

    # Build De Bruijn graph: nodes are (n-1)-mers; edges are n-grams (prefix -> suffix)
    adj: Dict[str, List[str]] = defaultdict(list)   # multigraph: store one entry per edge
    indeg: Dict[str, int] = defaultdict(int)
    outdeg: Dict[str, int] = defaultdict(int)

    for g in ngrams:
        u = g[:-1]
        v = g[1:]
        adj[u].append(v)
        outdeg[u] += 1
        indeg[v] += 1
        # Ensure v appears as a node key even if it has no outgoing edges
        if v not in adj:
            adj[v] = adj[v]  # touch key

    # Check Eulerian path/cycle degree conditions
    start_candidates = []
    end_candidates = []
    nodes = set(adj.keys()) | set(indeg.keys()) | set(outdeg.keys())

    for x in nodes:
        outx = outdeg.get(x, 0)
        inx = indeg.get(x, 0)
        if outx - inx == 1:
            start_candidates.append(x)
        elif inx - outx == 1:
            end_candidates.append(x)
        elif inx == outx:
            pass
        else:
            raise ValueError(f"No Eulerian path: node {x!r} has in={inx}, out={outx}")

    if len(start_candidates) > 1 or len(end_candidates) > 1:
        raise ValueError("No Eulerian path: too many start/end candidates.")
    # Choose start node
    if start_candidates:
        start = start_candidates[0]
    else:
        # Eulerian cycle: start anywhere with edges
        # If there are no edges (empty input), return empty string or raise
        nonempty = [x for x in nodes if outdeg.get(x, 0) > 0]
        if not nonempty:
            return ""  # or raise ValueError("No n-grams provided")
        start = nonempty[0]

    # Connectivity check (weakly connected on nodes with degree > 0)
    def is_weakly_connected() -> bool:
        active = {x for x in nodes if indeg.get(x, 0) + outdeg.get(x, 0) > 0}
        if not active:
            return True
        # Build undirected neighbors
        neighbors = defaultdict(set)
        for u, vs in adj.items():
            for v in vs:
                neighbors[u].add(v)
                neighbors[v].add(u)
        # Some nodes may appear only as sinks (in-degree>0, no outgoing); ensure they exist
        for v in active:
            neighbors[v]  # touch
        # BFS from start
        seen = set()
        q = deque([start])
        while q:
            cur = q.popleft()
            if cur in seen:
                continue
            seen.add(cur)
            for w in neighbors[cur]:
                if w not in seen:
                    q.append(w)
        return seen.issuperset(active)

    if not is_weakly_connected():
        raise ValueError("No Eulerian path: graph is not (weakly) connected.")

    # Hierholzerâ€™s algorithm (use a local copy; sort for deterministic output)
    local_adj = {u: sorted(vs, reverse=True) for u, vs in adj.items()}  # pop() from end => lexicographically smallest first
    stack = [start]
    path: List[str] = []
    while stack:
        v = stack[-1]
        if local_adj[v]:
            u = local_adj[v].pop()
            stack.append(u)
        else:
            path.append(stack.pop())
    path.reverse()  # sequence of nodes of length = edges + 1

    # Reconstruct string from node path
    if len(path) == 0:
        return ""
    # Verify number of edges matches input size
    if len(path) != len(ngrams) + 1:
        raise ValueError("No Eulerian path that uses all edges exactly once.")
    reconstructed = path[0] + "".join(node[-1] for node in path[1:])

    # Optional: verify multiset of n-grams matches exactly
    want = Counter(ngrams)
    got = Counter(reconstructed[i:i+n] for i in range(len(reconstructed) - n + 1))
    if want != got:
        raise ValueError("Reconstruction failed: n-gram multiset mismatch.")
    return reconstructed


# --- Demo / quick test ---
if __name__ == "__main__":
    import random

    k = 3

    grams = ['-4f', '-68', '-96', '-dc', '25-', '35-', '3ef', '3-9', '4fa', '5-4', '5-d', '625', '680', '683', '6fa', '768', '804', '835', '8b-', '8ce', '962', '9d8', 'a3-', 'a8b', 'b-6', 'c9d', 'ce7', 'd8c', 'dc9', 'e76', 'ef6', 'f6f', 'fa3', 'fa8']

    grams = ['-12', '-36', '-41', '-82', '0df', '0e3', '120', '13e', '1e-', '20e', '21e', '23d', '2ce', '350', '366', '3d5', '3e-', '413', '50d', '5f2', '66a', '6a-', '7f9', '821', 'a-4', 'ce-', 'd5f', 'df7', 'e35', 'e-1', 'e-3', 'e-8', 'f2c', 'f7f']

    grams = ['-2e', '-49', '-5a', '-86', '2e9', '2-5', '31f', '456', '487', '495', '56a', '59-', '5ae', '6ad', '6ca', '6b2', '6-4', '76c', '86b', '876', '8-2', '96-', '959', '9-8', 'a48', 'a8-', 'adc', 'ae4', 'b2-', 'c31', 'ca8', 'dc3', 'e45', 'e96']

    out = reconstruct_from_ngrams(grams, k)
    print("Reconstructed:", out)
    # Should print a string whose 3-grams are exactly `grams` (as a multiset).
