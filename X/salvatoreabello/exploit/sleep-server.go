package main

import (
	"strconv"
	"strings"
	"time"

	"github.com/valyala/fasthttp"
)

var workerSemaphore = make(chan struct{}, 4096)

func main() {
	if err := fasthttp.ListenAndServe(":80", requestHandler); err != nil {
		panic("Error in ListenAndServe: " + err.Error())
	}
}

func requestHandler(ctx *fasthttp.RequestCtx) {
	ctx.Response.Header.Set("Access-Control-Allow-Origin", "*")

	workerSemaphore <- struct{}{}
	defer func() { <-workerSemaphore }()

	path := string(ctx.Path())
	switch {
	case path == "/40sleep":
		time.Sleep(40 * time.Second)
		ctx.SetStatusCode(fasthttp.StatusOK)
		return

	case path == "/ssleep":
		time.Sleep(250 * time.Millisecond)
		ctx.SetStatusCode(fasthttp.StatusOK)
		return

	case strings.HasPrefix(path, "/ssleep/"):
		trimmed := strings.TrimPrefix(path, "/ssleep/")
		if ms, err := strconv.Atoi(trimmed); err == nil {
			time.Sleep(time.Duration(ms) * time.Millisecond)
			ctx.SetStatusCode(fasthttp.StatusOK)
			return
		}
		ctx.Error("Invalid milliseconds value", fasthttp.StatusBadRequest)
		return

	default:
		if len(path) > 1 {
			trimmed := strings.TrimPrefix(path, "/")
			if seconds, err := strconv.Atoi(trimmed); err == nil {
				time.Sleep(time.Duration(seconds) * time.Second)
				ctx.SetStatusCode(fasthttp.StatusOK)
				return
			}
		}
		ctx.Error("Not Found", fasthttp.StatusNotFound)
	}
}
